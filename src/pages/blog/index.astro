---
import Layout from "../../layouts/Layout.astro";
import { getAllBlog } from "../../lib/microcms";
import HoverIndicator from "../../components/HoverIndicator";
import ArticleCard from "../../components/ArticleCard";
import PageTitle from "../../components/PageTitle";
import "../../components/article-card.css";
import "../../components/page-title.css";

let blogs;
try {
  blogs = await getAllBlog();
} catch (error) {
  console.error("Failed to fetch blogs:", error);
  // 環境変数が設定されていない場合は空のデータを返す
  blogs = { contents: [], totalCount: 0, offset: 0, limit: 0 };
}

const formatDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString("ja-JP", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    timeZone: "Asia/Tokyo",
  });
};

const categories = [
  { id: "all", label: "All" },
  { id: "Programming", label: "Programming" },
  { id: "Coffee", label: "Coffee" },
  { id: "Design", label: "Design" },
  { id: "DailyLife", label: "Daily Life" }
];

---

<Layout title="Blog">
  <div class="blog-page">
    <PageTitle title="BLOG" client:load />
    <!-- Category Filter -->
    <div class="category-filter">
      <HoverIndicator 
        client:only="react"
        items={categories}
        onItemClick={(categoryId: string) => {
          console.log('Category clicked:', categoryId);
        }}
        className="filter-nav vertical"
        showBackground={true}
        enableBlogFilter={true}
      />
    </div>

    {
      blogs === null && (
        <p>
          記事の取得に失敗しました。環境変数やネットワークを確認してください。
        </p>
      )
    }
    {blogs && blogs.totalCount === 0 && <p>投稿はまだありません。</p>}
    {blogs && blogs.totalCount > 0 && (
      <>
        <!-- Pagination -->
        <div class="pagination-container">
          <button id="prev-page" class="pagination-btn" disabled>
            <svg width="20" height="20" viewBox="0 0 16 16" fill="none">
              <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            back
          </button>
          
          <div class="pagination-center">
            <!-- <div class="page-indicator">
              <span class="current-page" id="current-page">1</span>
              <span class="separator">/</span>
              <span class="total-pages" id="total-pages">1</span>
            </div> -->
            <div class="items-count">
              <span class="count-number" id="total-items">{blogs.totalCount}</span>
              <span class="count-label">articles</span>
            </div>
          </div>
          
          <button id="next-page" class="pagination-btn next-btn">
            next
            <svg width="20" height="20" viewBox="0 0 16 16" fill="none">
              <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <div class="blog-grid">
          {blogs.contents.map((blog) => (
            <ArticleCard
              client:load
              title={blog.title}
              summary={blog.summary}
              publishedAt={blog.publishedAt}
              thumbnail={blog.thumbnail}
              slug={blog.slug}
              category={blog.category}
            />
          ))}
        </div>
      </>
    )}
  </div>
</Layout>

<style>
  .blog-page {
    max-width: 75rem;
    margin: 0 auto;
    margin-left: 10rem;
    padding: 0 1rem;
    /* background: #f8fafc; より落ち着いたグレー背景 */
    min-height: 100vh;
    position: relative;
  }


  .blog-page h1 {
    color: #8b7355;
    margin-bottom: 2rem;
    text-align: center;
  }

  .category-filter {
    position: fixed;
    bottom: 2rem;
    left: 2rem;
    z-index: 1000;
    display: flex;
    justify-content: flex-start;
  }

  .category-filter .hover-indicator-nav.with-background {
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    padding: 0.75rem 0.5rem;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
  }


  .blog-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2rem;
    margin-top: 2rem;
    position: relative;
    z-index: 0;
  }

  @media (max-width: 47.9375rem) {
    .category-filter {
      bottom: 1rem;
      left: 1rem;
    }
    
    .category-filter .hover-indicator-nav.with-background {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.4rem;
      padding: 0.6rem 0.4rem;
    }

    .category-filter .hover-indicator-nav.vertical {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.4rem;
    }
    
    .blog-grid {
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }
  }


  /* Keyframe animations removed - GSAP handles all animations */

  @media (max-width: 767px) {
    .blog-grid {
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }
    

    .filter-nav {
      flex-direction: column;
      gap: 0.6rem;
    }

    .filter-button {
      padding: 8px 16px;
      font-size: 13px;
    }
  }

  .no-blogs-message {
    grid-column: 1 / -1;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 20rem;
    animation: fadeIn 0.5s ease-in-out;
  }

  .no-blogs-content {
    text-align: center;
    padding: 3rem 2rem;
    background: #ffffff;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    border: 1px solid #e2e8f0;
  }

  .no-blogs-content h3 {
    color: #374151;
    font-size: 1.5rem;
    font-weight: 600;
    margin: 0 0 1rem 0;
  }

  .no-blogs-content p {
    color: #6b7280;
    font-size: 1rem;
    margin: 0;
    line-height: 1.5;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(1rem);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* All keyframe animations removed - GSAP provides smoother animations */

  /* Pagination Styles */
  .pagination-container {
    margin-top: 3rem;
    margin-bottom: 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 70rem;
    gap: 3rem;
  }

  .pagination-center {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    flex: 1;
  }

  .page-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: #ffffff;
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    border: 1px solid #e2e8f0;
  }

  .current-page {
    font-size: 1.5rem;
    font-weight: 600;
    color: #8b7355;
    min-width: 1.5rem;
    text-align: center;
  }

  .separator {
    font-size: 1.2rem;
    font-weight: 300;
    color: #9ca3af;
  }

  .total-pages {
    font-size: 1.2rem;
    font-weight: 500;
    color: #6b7280;
    min-width: 1.5rem;
    text-align: center;
  }

  .items-count {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.9rem;
    color: #6b7280;
  }

  .count-number {
    font-size: 1.8rem;
    font-weight: 600;
    color: #8b7355;
    line-height: 1;
  }

  .count-label {
    font-size: 0.75rem;
    font-weight: 500;
    color: #9ca3af;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }


  .pagination-btn {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    padding: 0.8rem 1.5rem;
    background: none;
    border: none;
    color: #64748b;
    font-size: 1.4rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
    border-radius: 8px;
  }

  .pagination-btn:hover:not(:disabled) {
    color: #374151;
  }

  .pagination-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    transform: none;
  }

  .pagination-btn:disabled::after {
    display: none;
  }

  .next-btn {
    margin-left: 4rem;
  }


  /* タブレットサイズ */
  @media (max-width: 1024px) {
    .blog-page {
      margin-left: 8rem;
    }
  }

  @media (max-width: 768px) {
    .blog-page {
      margin-left: 5rem;
    }
  }

  /* 小さなモバイルサイズ */
  @media (max-width: 480px) {
    .blog-page {
      margin-left: 3.5rem;
    }
  }

  /* 非常に小さなモバイルサイズ */
  @media (max-width: 320px) {
    .blog-page {
      margin-left: 2.5rem;
    }
  }

  @media (max-width: 767px) {
    .pagination-container {
      display: none;
    }
  }
</style>

<script>
  import { gsap } from 'gsap';

  // Pagination functionality
  class BlogPagination {
    itemsPerPage: number;
    currentPage: number;
    currentCategory: string;
    allBlogs: Element[];
    filteredBlogs: Element[];
    totalPages: number;
    isMobile: boolean;

    constructor() {
      this.itemsPerPage = 6;
      this.currentPage = 1;
      this.currentCategory = 'all';
      this.allBlogs = [];
      this.filteredBlogs = [];
      this.totalPages = 1;
      this.isMobile = window.innerWidth <= 767;
      
      this.init();
    }

    init(): void {
      // Get all blog cards
      this.allBlogs = Array.from(document.querySelectorAll('.blog-card'));
      this.filteredBlogs = [...this.allBlogs];
      
      // Calculate total pages
      this.totalPages = Math.ceil(this.filteredBlogs.length / this.itemsPerPage);
      
      // Initialize pagination
      this.updatePaginationUI();
      
      // Show all blogs on mobile, paginated on desktop
      if (this.isMobile) {
        this.showAllBlogs();
      } else {
        this.showPage(1);
      }
      
      // Add event listeners
      this.addEventListeners();
    }

    addEventListeners(): void {
      const prevBtn = document.getElementById('prev-page');
      const nextBtn = document.getElementById('next-page');
      
      if (prevBtn) prevBtn.addEventListener('click', () => this.previousPage());
      if (nextBtn) nextBtn.addEventListener('click', () => this.nextPage());
    }

    filterByCategory(categoryId: string): void {
      this.currentCategory = categoryId;
      this.currentPage = 1;
      
      // Filter blogs by category
      this.filteredBlogs = this.allBlogs.filter(blog => {
        const blogCategory = blog.getAttribute('data-category');
        return categoryId === 'all' || blogCategory === categoryId;
      });
      
      // Recalculate total pages
      this.totalPages = Math.ceil(this.filteredBlogs.length / this.itemsPerPage);
      
      // Update UI with wave animation
      this.updatePaginationUI();
      
      // Show all blogs on mobile, paginated on desktop
      if (this.isMobile) {
        this.showAllBlogsWithAnimation();
      } else {
        this.showPageWithWaveAnimation(1);
      }
    }

    showPage(page: number): void {
      this.currentPage = page;
      
      // Hide all blogs first
      this.allBlogs.forEach(blog => {
        (blog as HTMLElement).style.display = 'none';
      });
      
      // Show blogs for current page
      const startIndex = (page - 1) * this.itemsPerPage;
      const endIndex = startIndex + this.itemsPerPage;
      
      this.filteredBlogs.slice(startIndex, endIndex).forEach(blog => {
        (blog as HTMLElement).style.display = 'block';
      });
      
      // Update pagination UI
      this.updatePaginationUI();
      
      // Show no blogs message if needed
      if (this.filteredBlogs.length === 0) {
        this.showNoBlogsMessage();
      } else {
        this.hideNoBlogsMessage();
      }
    }

    showAllBlogs(): void {
      // Hide all blogs first
      this.allBlogs.forEach(blog => {
        (blog as HTMLElement).style.display = 'none';
      });
      
      // Show all filtered blogs
      this.filteredBlogs.forEach(blog => {
        (blog as HTMLElement).style.display = 'block';
      });
      
      // Show no blogs message if needed
      if (this.filteredBlogs.length === 0) {
        this.showNoBlogsMessage();
      } else {
        this.hideNoBlogsMessage();
      }
    }

    showAllBlogsWithAnimation(): void {
      // Show no blogs message if needed
      if (this.filteredBlogs.length === 0) {
        this.hideAllBlogs();
        this.showNoBlogsMessage();
        return;
      } else {
        this.hideNoBlogsMessage();
      }
      
      // Start smooth motion tile animation for all blogs
      this.startMotionTileAnimation(this.filteredBlogs);
    }

    showPageWithWaveAnimation(page: number): void {
      this.currentPage = page;
      
      // Get all visible blogs for current page
      const startIndex = (page - 1) * this.itemsPerPage;
      const endIndex = startIndex + this.itemsPerPage;
      const visibleBlogs = this.filteredBlogs.slice(startIndex, endIndex);
      
      // Show no blogs message if needed
      if (this.filteredBlogs.length === 0) {
        this.hideAllBlogs();
        this.showNoBlogsMessage();
        this.updatePaginationUI();
        return;
      } else {
        this.hideNoBlogsMessage();
      }
      
      // Start smooth motion tile animation
      this.startMotionTileAnimation(visibleBlogs);
      
      // Update pagination UI
      this.updatePaginationUI();
    }

    hideAllBlogs(): void {
      this.allBlogs.forEach(blog => {
        const blogElement = blog as HTMLElement;
        blogElement.style.display = 'none';
        
        // Clear all animation classes
        blogElement.classList.remove('animating', 'animating-in', 'animating-out', 'hidden', 'fade-out', 'fade-in', 'domino-in');
        
        // Clear GSAP animations
        gsap.killTweensOf(blogElement);
      });
    }

    calculateGridPositions(blogs: Element[]): Array<{blog: Element, row: number, col: number}> {
      const positions: Array<{blog: Element, row: number, col: number}> = [];
      const gridCols = 3; // 3列のグリッド
      
      blogs.forEach((blog, index) => {
        const row = Math.floor(index / gridCols);
        const col = index % gridCols;
        positions.push({ blog, row, col });
      });
      
      return positions;
    }

    startMotionTileAnimation(visibleBlogs: Element[]): void {
      // Step 1: Hide all blogs first
      this.hideAllBlogs();
      
      // Step 2: Calculate grid positions for wave animation
      const gridPositions = this.calculateGridPositions(visibleBlogs);
      
      // Step 3: Sort by distance from bottom-right (row desc, then col desc)
      gridPositions.sort((a, b) => {
        if (a.row !== b.row) {
          return b.row - a.row; // 下の行から上へ
        }
        return b.col - a.col; // 右の列から左へ
      });
      
      // Step 4: Start GSAP-powered smooth wave animation
      this.startGSAPWaveAnimation(gridPositions);
    }

    startGSAPWaveAnimation(positions: Array<{blog: Element, row: number, col: number}>): void {
      // Set initial state for all blogs
      positions.forEach((position) => {
        const blog = position.blog as HTMLElement;
        blog.style.display = 'block';
        
        // Set initial GSAP properties - more dramatic rotation
        gsap.set(blog, {
          opacity: 0,
          rotationY: -720, // 2 full rotations (720 degrees)
          scale: 0.6,
          z: -200,
          filter: 'blur(6px)',
          transformOrigin: 'center center'
        });
      });

      // Create timeline for staggered animation
      const tl = gsap.timeline({
        delay: 0.3, // Initial delay
        onComplete: () => {
          console.log('Animation completed');
        }
      });

      // Add each blog to timeline with stagger - right-bottom to left-top
      positions.forEach((position, index) => {
        const blog = position.blog as HTMLElement;
        
        // Phase 1: Fast spinning in place (multiple rotations)
        tl.to(blog, {
          duration: 2.5,
          rotationY: -360, // Spin from -720 to -360 (1 full rotation)
          ease: 'power4.out',
          delay: index * 0.25 // 250ms stagger for more dramatic effect
        }, index * 0.25);

        // Phase 2: Continue spinning while fading in and scaling
        tl.to(blog, {
          duration: 1.8,
          opacity: 1,
          scale: 1,
          z: 0,
          filter: 'blur(0px)',
          rotationY: 0, // Complete the spin to final position
          ease: 'power3.out'
        }, index * 0.25 + 0.8);

        // Phase 3: Final flourish - small extra spin
        tl.to(blog, {
          duration: 0.6,
          rotationY: 180, // Half rotation flourish
          ease: 'power2.out'
        }, index * 0.25 + 2.3);

        // Phase 4: Settle into final position
        tl.to(blog, {
          duration: 0.4,
          rotationY: 0, // Back to normal
          ease: 'power2.out'
        }, index * 0.25 + 2.7);
      });

      // Add a final collective bounce effect after all animations
      tl.to(positions.map(p => p.blog), {
        duration: 0.5,
        scale: 1.08,
        ease: 'power2.out',
        yoyo: true,
        repeat: 1
      }, '-=0.5');
    }

    updatePaginationUI(): void {
      const currentPageEl = document.getElementById('current-page');
      const totalPagesEl = document.getElementById('total-pages');
      const totalItemsEl = document.getElementById('total-items');
      const prevBtn = document.getElementById('prev-page') as HTMLButtonElement;
      const nextBtn = document.getElementById('next-page') as HTMLButtonElement;
      
      if (currentPageEl) currentPageEl.textContent = this.currentPage.toString();
      if (totalPagesEl) totalPagesEl.textContent = this.totalPages.toString();
      if (totalItemsEl) totalItemsEl.textContent = this.filteredBlogs.length.toString();
      
      // Update button states
      if (prevBtn) prevBtn.disabled = this.currentPage === 1;
      if (nextBtn) nextBtn.disabled = this.currentPage === this.totalPages;
      
    }


    previousPage(): void {
      if (this.currentPage > 1) {
        this.showPage(this.currentPage - 1);
      }
    }

    nextPage(): void {
      if (this.currentPage < this.totalPages) {
        this.showPage(this.currentPage + 1);
      }
    }

    showNoBlogsMessage(): void {
      const blogGrid = document.querySelector('.blog-grid');
      if (!blogGrid) return;

      this.hideNoBlogsMessage();
      
      const messageDiv = document.createElement('div');
      messageDiv.className = 'no-blogs-message';
      messageDiv.innerHTML = `
        <div class="no-blogs-content">
          <h3>表示するブログがありません</h3>
          <p>「${this.currentCategory === 'all' ? 'All' : this.currentCategory}」カテゴリーにはまだブログが投稿されていません。</p>
        </div>
      `;
      
      blogGrid.appendChild(messageDiv);
    }

    hideNoBlogsMessage(): void {
      const blogGrid = document.querySelector('.blog-grid');
      if (!blogGrid) return;
      
      const existingMessage = blogGrid.querySelector('.no-blogs-message');
      if (existingMessage) {
        existingMessage.remove();
      }
    }
  }

  // Extend window object for pagination
  declare global {
    interface Window {
      blogPagination?: {
        filterByCategory: (categoryId: string) => void;
        showPage: (page: number) => void;
        previousPage: () => void;
        nextPage: () => void;
      };
    }
  }

  // Initialize pagination when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    window.blogPagination = new BlogPagination();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      if (window.blogPagination) {
        const wasMobile = window.blogPagination.isMobile;
        window.blogPagination.isMobile = window.innerWidth <= 767;
        
        // If mobile state changed, reinitialize display
        if (wasMobile !== window.blogPagination.isMobile) {
          if (window.blogPagination.isMobile) {
            window.blogPagination.showAllBlogs();
          } else {
            window.blogPagination.showPage(1);
          }
        }
      }
    });
  });
</script>

